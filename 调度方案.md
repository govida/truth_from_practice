# 调度方案

今天与耀民大佬讨论了下抓取方案，感觉受益良多，特此记录下

## 背景

对持续进入表A中的热点事件a进行监控，抓取与热点事件相关的新闻b存于表B中

其中，热点事件a与相关新闻b是1对N的关系

## 需求

对新进入的表A的热点事件a，应当尽可能快的抓取，对于历史热点事件a'也需要不停的更新，直到某一标志位提示放弃抓取

其中设计两个需求：

- 对新进热点事件的”立即“抓取（优先级高，时延短）
- 对历史热点事件的持续跟踪（优先级较低，但一定要能跟踪）

## 方案A

### “立即”抓取

首先，为了解决对新进热点事件的“立即”抓取，采用全局队列+消费进程的方式：

- 全局队列：用于接收新进的热点事件，将其放入队列的头部
- 消费进程：监听全局队列，不停的从队列头部提取事件进行消费

这种情况下，可能存在热点事件饥饿致死，不过实质上，是消费进程不够，消费不过来推送的热点事件

这里我们假设消费进程有能力单纯地消费最新热点，但除此之外，要同时对历史热点进行消费会存在一定的压力

### 持续跟踪

同时，为了解决对历史热点事件的持续跟踪，需要一个定时任务，持续的从库中抓取最近处于热点状态的事件，将其不断的推送到全局队列的方式

这里我们考虑两种推送方式：

- 推送到头部：
  - 可能会压制部分当前的需要“立即”抓取的任务，导致“立即”抓取时延变长
  - 可能会导致饥饿，率先被推进队列的事件，可能无法得到消费
- 推送到尾部（可行）：
  - 能够保证“立即”抓取的语义
  - 在“立即”抓取完成的情况下，可以避免饥饿

但这种情况下，可能存在同一热点任务被重复抓取投放到全局队列中，我们需要额外的标识符来标识当前热点事件已经在全局队列中，消费完后，reset该标志位

上述方案成本如下：

- 全局队列
- 消费进程
- 定时任务
- 标志在全局队列的字段

## 方案B

我本以为方案A完美解决了上述需求，这时耀民大佬提出了一种，我一开始以为是种很low，仔细琢磨真香的方案

先说其成本：

- 定时消费任务
- 标志热点事件上次被消费的时间字段

### 总体策略

定时的从热点事件表A拉取最久的一批未更新的热点事件，进行统一消费

- 最久：
  - 保证新进热点事件，在不断地更新（新进事件，置为从很远以前开始的，这样会立即被抓上来进行消费）
  - 保证所有热点事件，都能得到消费
- 小批：避免饥饿

以极低的成本解决了上述两个问题！个人感觉无懈可击~

## 分布式讨论

方案A的定时拉取 与 方案B的定时拉取都需要一定的策略来避免重复消费实体，可以采用hash key的方式来解决